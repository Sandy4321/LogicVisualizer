<!DOCTYPE html>
<html>
<head>

<script type="text/javascript">
function TreeNode() {
}
TreeNode.prototype = {
	chlids: null,
	parent: null,
	subtreeleftwidth: 0,
	subtreerightwidth: 0,
	element: null,
	loadData: function(data) {
		//? childs
		this.childs = [];
		var i = 0;
		var treenode;
		for (i = 0;i<data.childs.length; i++) {
			if (data.childs[i] != null) {
				treenode = new TreeNode();
				treenode.element = new Rule("TEMP");
				treenode.loadData(data.childs[i]);
				this.childs.push(treenode);
			} else {
				this.childs.push(null);
			}
		}
		this.subtreeleftwidth = data.subtreeleftwidth;
		this.subtreerightwidth = data.subtreerightwidth;
		this.element.loadData(data.element);
	}
}

function Tree(root) {
	this.rootnode = new TreeNode();
	this.rootnode.element = root;
	this.rootnode.childs = [null];
}
Tree.prototype = {
	rootnode: null,
	offset: 3,
	loadData: function(data) {
		this.rootnode.loadData(data.rootnode);
	},
	deleteElement: function(node,childnum) {	
		//go through all
		var stack = [0];
		var curnode = node.childs[childnum];
		var curchildnum;
		
		if(curnode == null) {
			return;
		}
		
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();

				var i = 0;
				curnode.childs = null; //их обнулили до этого
				curnode.element = null;
					
				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					curnode.childs[curchildnum].parent = null;
					curnode.childs[curchildnum] = null;
					stack[stack.length-1] = curchildnum+1;
				} else {
					curnode.parent = null;
				}
			}
		}
		node.childs[childnum] = null;		
		
		this.changed(node);
	},
	addElement: function(parent,element,type) {
		//check parent.element.focusedelem
		var treenode = new TreeNode();
		
		if (type == "right") {
			parent.childs[1] = treenode;
			treenode.element = element;
			element.x = parent.element.x+parent.element.width/2+this.offset;
			element.y = parent.element.y-element.height - this.offset;
		} else if (type == "left") {
			parent.childs[0] = treenode;
			treenode.element = element;		
			element.x = parent.element.x+parent.element.width/2-element.width-this.offset;
			element.y = parent.element.y-element.height - this.offset;
		} else if (type == "center") {
			parent.childs[0] = treenode;
			treenode.element = element;		
			element.x = parent.element.x+parent.element.width/2-element.width/2;
			element.y = parent.element.y-parent.element.height - this.offset;			
		}
		if (treenode.element.type == "MP") {
			treenode.childs = [null, null];
		} else if (treenode.element.type == "GEN") {
			treenode.childs = [null];
		}
		treenode.parent = parent;
		
		this.changed(treenode);
	},
	deleteParents: function() {
		var curnode = this.rootnode;
		var childnode;
		var stack = [0];
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				if (stack.length != 0) {
					//Go to parent
					childnode = curnode;
					curnode = curnode.parent;
					childnode.parent=null;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				}
			}
		}
	},
	addParents: function() {
		var curnode = this.rootnode;
		var parentnode;
		var stack = [0];
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					parentnode = curnode;
					curnode = curnode.childs[curchildnum];
					curnode.parent = parentnode;
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				}
			}
		}
	},
	recountTree: function(context) {
		//walk up from current node
		
		var curnode = this.rootnode;
		var stack = [0];
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				curnode.element.setSize(context);

				//@TODO set subtreewidth
				if (curnode.childs.length == 1) {
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreeleftwidth;
					} else { twidth = 0; }
					curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth);			
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreerightwidth;
					} else { twidth = 0; }
					curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth);
					
				} else if (curnode.childs.length == 2) {
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreeleftwidth+
							curnode.childs[0].subtreerightwidth;
					} else { twidth = 0; }
					curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth)
						+2*this.offset;			
					if (curnode.childs[1] != null) {
						twidth = curnode.childs[1].subtreerightwidth+
							curnode.childs[1].subtreeleftwidth;
					} else { twidth = 0; }
					curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth)
						+2*this.offset;				
					
				} else {
					console.log("Tree.changed: logic error");
				}

				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				} else {
					//@TODO:set x,y of curnode
				}
			}
		}
		this.changed(this.rootnode);
	},
	changeRule: function(node,elementnum,rulevalue,context) {
		//walk up from current node
		
		if (elementnum == 1 || node.element.type=="GEN" || elementnum==2) {
			if (node.element.elems[elementnum] != rulevalue) {
				alert("Cannot change this. You can change this field through other elements");
				return;
			}
		} else {
			node.element.elems[elementnum] = rulevalue;
			
			if (node.element.type == "MP"){
				node.element.autosetmp(rulevalue,node.element.elems[2]);
			}
			
			node.element.setSize(context);
		}
		
		var curnode = node;
		var stack = [0];
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					//@TODO:set x,y of curnode.
					//set curnode from parent
					if (curnode.element.type == "MP") {
						curnode.element.autosetmp(curnode.element.elems[0],
							curnode.parent.element.elems[curchildnum]);
					} else if (curnode.element.type == "GEN") {
						if (!curnode.element.autosetgen(
							curnode.parent.element.elems[curchildnum])) {
							curnode = curnode.parent;
							this.deleteElement(curnode,curchildnum);
							continue;
						}
					}
					
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				curnode.element.setSize(context);

				//@TODO set subtreewidth
				if (curnode.childs.length == 1) {
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreeleftwidth;
					} else { twidth = 0; }
					curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth);			
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreerightwidth;
					} else { twidth = 0; }
					curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth);
					
				} else if (curnode.childs.length == 2) {
					if (curnode.childs[0] != null) {
						twidth = curnode.childs[0].subtreeleftwidth+
							curnode.childs[0].subtreerightwidth;
					} else { twidth = 0; }
					curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth)
						+2*this.offset;			
					if (curnode.childs[1] != null) {
						twidth = curnode.childs[1].subtreerightwidth+
							curnode.childs[1].subtreeleftwidth;
					} else { twidth = 0; }
					curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth)
						+2*this.offset;				
					
				} else {
					console.log("Tree.changed: logic error");
				}

				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				} else {
					//@TODO:set x,y of curnode
				}
			}
		}
		
		//this.changed(this.rootnode);
		this.changed(node);
		
	},
	//drawer.logictree.changeRule(infocuselem,layout.edittext.value);
	changed: function(node) {
		//recount positions from node;
		
		//1. Go to the root - change all values, then, recount all tree
		var curnode = node;
		var twidth = 0;
		while(curnode != null) {
			//? which was prev - left or right - does not matter
			if (curnode.childs.length == 1) {
				if (curnode.childs[0] != null) {
					twidth = curnode.childs[0].subtreeleftwidth;
				} else { twidth = 0; }
				curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth);			

				if (curnode.childs[0] != null) {
					twidth = curnode.childs[0].subtreerightwidth;
				} else { twidth = 0; }
				curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth);
				
			} else if (curnode.childs.length == 2) {
				if (curnode.childs[0] != null) {
					twidth = curnode.childs[0].subtreeleftwidth+
						curnode.childs[0].subtreerightwidth;
				} else { twidth = 0; }
				curnode.subtreeleftwidth = Math.max(curnode.element.width/2, twidth)
					+2*this.offset;			

				if (curnode.childs[1] != null) {
					twidth = curnode.childs[1].subtreerightwidth+
						curnode.childs[1].subtreeleftwidth;
				} else { twidth = 0; }
				curnode.subtreerightwidth = Math.max(curnode.element.width/2, twidth)
					+2*this.offset;				
				
			} else {
				console.log("Tree.changed: logic error");
			}
			curnode = curnode.parent;
		}
		
		//2. recount coordinates of tree, node element has 0,0
		var stack = [0];
		curnode = this.rootnode;
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					//@TODO:set x,y of curnode.
					//get parent center
					var parentx = (curnode.parent.element.x+curnode.parent.element.width/2);
					var parenty = (curnode.parent.element.y);
					//set center 
					if (curnode.parent.childs.length == 2) {
						if (curchildnum == 0) {
							//left
							curnode.element.x = parentx - curnode.subtreerightwidth - curnode.element.width/2 -
								this.offset;
							curnode.element.y = parenty - curnode.element.height - 4*this.offset;
						} else if (curchildnum == 1) {
							//right
							curnode.element.x = parentx + curnode.subtreeleftwidth - curnode.element.width/2 +
								this.offset;
							curnode.element.y = parenty - curnode.element.height - 4*this.offset;
						}
					} else if (curnode.parent.childs.length == 1) {
						if (curchildnum == 0) {
							//center
							curnode.element.x = parentx - curnode.element.width/2;
							curnode.element.y = parenty - curnode.element.height - 4*this.offset;
						}
					}
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
					
				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				} else {
					//@TODO:set x,y of curnode
				}
			}
		}
	}
}

utfsymb = {
	forall:"\u2200",
	exist:"\u2203",
	not:"\u00ac",
	or: "\u2228",
	and: "\u2227",
	implic: "\u2192"
};

function Rule(type="",x = 0,y = 0,width = 0,height = 0) {
	//alert("Rule 2");
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.type = type;
	if (type == "MP") {
		this.elems = ["","",""];
	} else if (type == "GEN") {
		this.elems = ["", ""];
	} else if (type == "Root") {
		this.elems = [""];
	} else if (type == "TEMP") {
	}else {
		alert("Rule: wrong type!");
	}
}
Rule.prototype = {
	expressions: null,
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	isFocused: false,
	fields: null,
	type: null,
	elems: null,
	elemrects: null,
	offset: 5,
	focusedelem: -1,
	loadData: function(data) {
		this.x = data.x;
		this.y = data.y;
		this.width = data.width;
		this.height = data.height;
		this.type = data.type;
		//elems and elemrects
		this.elems =[];
		var i = 0;
		for (i = 0;i<data.elems.length;i++) {
			this.elems.push(data.elems[i]);
		}
		this.elemrects = [];
		var rect;
		for (i = 0;i<data.elemrects.length;i++) {
			this.elemrects.push(data.elemrects[i]);
		}
	},
	setSize: function(context) {
		if (this.type == "MP") {
			if (this.elemrects == null) {
				this.elemrects = [];
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
			}
			{
				//coordinats inside rule
				this.elemrects[0].x = 0;
				this.elemrects[0].y = 0;
				this.elemrects[0].width = context.measureText(this.elems[0]).width + 2*this.offset;
				this.elemrects[0].height = parseInt(context.font);
				this.elemrects[1].x = this.elemrects[0].width;
				this.elemrects[1].y = 0;
				this.elemrects[1].width = context.measureText(this.elems[1]).width + 
					2*this.offset;
				this.elemrects[1].height = parseInt(context.font);
				this.elemrects[2].x = 0;
				this.elemrects[2].y = this.elemrects[0].height;
				this.elemrects[2].width = context.measureText(this.elems[2]).width + 
					2*this.offset;
				this.elemrects[2].height = parseInt(context.font);
			}
			this.width = Math.max(this.elemrects[0].width+this.elemrects[1].width,
				this.elemrects[2].width);
			this.height = 2*parseInt(context.font);
				
			this.elemrects[2].x = (this.width-this.elemrects[2].width) / 2
		} else if (this.type == "GEN") {
			//GEN - universal generalization
			if (this.elemrects == null) {
				this.elemrects = [];
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
			}
			{
				//coordinats inside rule
				this.elemrects[0].x = 0;
				this.elemrects[0].y = 0;
				this.elemrects[0].width = context.measureText(this.elems[0]).width + 2*this.offset;
				this.elemrects[0].height = parseInt(context.font);
				this.elemrects[1].x = 0;
				this.elemrects[1].y = parseInt(context.font);
				this.elemrects[1].width = context.measureText(this.elems[1]).width + 
					2*this.offset;
				this.elemrects[1].height = parseInt(context.font);
			}
			this.width = Math.max(this.elemrects[0].width,this.elemrects[1].width);
			this.height = 2*parseInt(context.font);			
			
			this.elemrects[0].x = (this.width-this.elemrects[0].width) / 2;
			this.elemrects[1].x = (this.width-this.elemrects[1].width) / 2;
		} else if (this.type == "Root") {
			//only one text field
			if (this.elemrects == null) {
				this.elemrects = [];
				this.elemrects.push({x: 0,y: 0, width: 0, height: 0});
			}
			{
				//coordinats inside rule
				this.elemrects[0].x = 0;
				this.elemrects[0].y = 0;
				this.elemrects[0].width = context.measureText(this.elems[0]).width + 2*this.offset;
				this.elemrects[0].height = parseInt(context.font);
				this.width = this.elemrects[0].width;
				this.height = parseInt(context.font);			
			}
		}
	},
	isolate: function(stringrule) {
		var reg = new RegExp("^\\s*(\\(.*\\))\\s*$");
		var match = stringrule.match(reg);
		if (match != null) {
			var string = match[1];
			//check brackets balance
			var i = 0,counter = 0;
			while(i<string.length) {
				if (string[i] == "(") { counter = counter+1; }
				else if (string[i] == ")") { counter = counter - 1;}
				i++;
				if (counter == 0 && i<string.length) {
					return ("("+stringrule+")");
				}
			}
			if (counter != 0) {
				alert("brackets are not balanced");
			}
			return string;
		} else {
			return ("("+stringrule+")");
		}
	},
	autosetmp: function(stringrule0, stringrule2) {
		//stringrule0->stringrule2
		this.elems[0] = stringrule0;
		this.elems[1] = this.isolate(stringrule0)+utfsymb.implic
			+this.isolate(stringrule2);
		this.elems[2] = stringrule2;
	},
	autosetgen: function(stringrule1) {
		//can or cannot use this rule
		var reg = new RegExp("^\\s*"+utfsymb.forall+"\\s*\\(\\s*\\D\\w*\\s*\\)\\s*"+"(.*)$");
		var match = stringrule1.match(reg);
		if (match == null) { return false; }
		this.elems[0] = match[1];
		this.elems[1] = stringrule1;
		return true;
	},
	drawTextFields: function(context,offsetx,offsety) {
		var i = 0;
		var elem;
		var elemrect;
		for (i = 0 ; i<this.elems.length;i++) {
			context.fillStyle = "rgba(0,0,0,1)";
			elemrect = this.elemrects[i];
			context.fillText(this.elems[i], this.x-offsetx+elemrect.x+this.offset,
				this.y-offsety+elemrect.y+elemrect.height-2);
			if (this.focusedelem == i) {
				context.fillStyle = "rgba(0,255,255,0.3)";
				context.fillRect(this.x-offsetx+elemrect.x,
					this.y-offsety+elemrect.y,elemrect.width,elemrect.height);
			}
		}
		context.rect(this.x-offsetx,this.y-offsety,this.width,this.height);
	},
	
	inRect: function(x,y,rect) {
		//alert("inrect "+x+" "+y+" "+" "+rectx+" "+recty+" "+width+" "+height);
		if (x>=rect.x && y>=rect.y && x<=rect.x+rect.width && y<=rect.y+rect.height) {
			return true;
		} else {
			return false;
		}
	},
	
	setFocus:function(x,y) {
		//get focus element
		this.isFocused = true;
		var i = 0;
		var elemrect;
		for (i = 0; i<this.elemrects.length; i++) {
			elemrect = this.elemrects[i];
			if (this.inRect(x,y,elemrect)) {
				this.focusedelem = i;
				/*
				if (this.type == "MP" && i == 2) {
					this.focusedelem = -1;
				} else if (this.type == "GEN" && i==1) {
					this.focusedelem = -1;
				} else {
					this.focusedelem = i;
				}*/
				return;
			}
			//there need to draw text + rect
			//set style: stroke + fillStyle
		}
	},
	unsetFocus: function() {
		this.isFocused = false;
		this.focusedelem = -1;
	},
	draw: function(context,offsetx,offsety) {
		//??canvas left top offset in scene
		//offset = offset + (startx-currentx)
		if (this.type == "MP") {
			//elems - 3
		} else if (this.type == "GEN") {
			//elems - 2
		} else if (this.type == "Root") {
			//elems - 1
		}
		this.setSize(context);
		//context.fillStyle = "rgba(255,0,0,1)";
		//context.strokeStyle = "rgba(255,0,0,1)";
		//context.strokeStyle = "rgba(0,0,0,1)";
		this.drawTextFields(context,offsetx,offsety);
	}
}

//===========================================
function readBracket(string, offset) {
	var i = 0;
	counter = 0;
	if (string[offset] != "(") { return 0; }
	for (i = offset;i<string.length;i++) {
		if (string[i]=="(") {
			counter++;
		} else if (string[i]==")") {
			counter--;
		}
		if (counter==0) {
			return i-offset+1;
			//return string.substr(offset+1,i-offset-1);
		}
	}
	return string.length-offset;
};

function readParams(string) {
	var params = [];
	var i = 0;
	var start = 0;
	var brackets = 0;
	for (i = 0;i<string.length;i++) {
		if (string[i] == "(") {
			brackets++;
		} else if (string[i] == ")") {
			brackets--;
		} else if (string[i] == "," && brackets==0) {
			params.push(string.substring(start,i));
			start = i+1;
		}
	}
	if (string.length > 0) {
		params.push(string.substring(start,string.length));
	}
	return params;
}

function readFunctional(namereg,string) {
	var result = namereg.exec(string);
	if (result == null) { return result; }
	var len = readBracket(string,result.index+result[0].length-1);
	//console.log("readFunctional: ",result,result.index+result[0].length-1,result.index+result[0].length-1+len-1);
	return [result.index,result.index+result[0].length-1,
		result.index+result[0].length+len-2];
}

function parseFunctional(func,string) {
		//check :=
	string = normalize(string);
	func.string = string;
	var split = string.split(":=");
	if (split.length != 2 || split[0]=="" || split[1]=="") {
		return false;
	}
	func.value = split[1];
	//work with split[0]
	var namereg = /\w+/.exec(split[0]);
	if (namereg.index != 0) {
		alert("There are no functional name");
		return false;
	}
	func.name = namereg[0];
	var varslen;
	if ((varslen = readBracket(split[0],func.name.length)-2) <= 0) {
		func.vars = [];
		//return false;
	} else {
		func.vars = split[0].substr(func.name.length+1,varslen).split(",");
	}
	console.log(func.name,varslen);
	return true;
}

function normalize(string, mode) {
	var reg = new RegExp("\\s+","g");
	if (mode!="isolate") {
		string = string.replace(reg,"");
	} else {
		string = "("+string.replace(reg,"")+")";
	}
	//remove double brackets
	var brackpairs = [];
	var r = 0,l = 0, i = 0;
	for (i = 0;i<string.length;i++) {
		if (string[i] == "(") {
			brackpairs.push({"l": i, "r": -1});
			l++;
		} else if (string[i] == ")") {
			r = l-1;
			while(brackpairs[r]["r"]!=-1){
				r--;
			}
			brackpairs[r]["r"] = i;
		}
	}
	
	var isolated;
	if (brackpairs.length!=0 && brackpairs[0]["l"]==0 &&
		brackpairs[0]["r"]==string.length-1) {
		isolated = true;
	} else {
		isolated = false;
	}
	
	//console.log(string);
	//console.log(brackpairs);
	
	for (i = 0;i<brackpairs.length-1;i++) {
		if (brackpairs[i]["l"]==brackpairs[i+1]["l"]-1 && 
			brackpairs[i]["r"]==brackpairs[i+1]["r"]+1) {
			string = string.substr(0,brackpairs[i]["l"])+" "+
				string.substr(brackpairs[i]["l"]+1,brackpairs[i]["r"]-brackpairs[i]["l"]-1)+" "+
				string.substr(brackpairs[i]["r"]+1,string.length-brackpairs[i]["r"]-1);
				brackpairs.splice(i,1);
				i--;
		}
	}
	
	//console.log(string);
	//console.log(brackpairs);
	
	/*
	reg = new RegExp("\\s+","g");
	string = string.replace(reg,"");*/
	
	//remove brackets if inside functional or variable
	//but we need to be carefull!!!
	var substr,result;
	for (i = 0;i<brackpairs.length;i++) {
		//continue if there are symb before bracket
		if (brackpairs[i]["l"]!=0)
		{
			if (
				string.substring(0,brackpairs[i]["l"]).match(/\w+\s*$/) ||
				string[brackpairs[i]["l"]-1]==utfsymb.forall ||
				string[brackpairs[i]["l"]-1]==utfsymb.exist ||
				string[brackpairs[i]["l"]-1]==")" ) {
				continue;
			}
		}
		//continue if there are symb after bracket
		if (brackpairs[i]["r"]<string.length-1)
		{
			if (
				string[brackpairs[i]["r"]+1].match(/\w/)) {
				continue;
			}
		}
		substr = string.substring(brackpairs[i]["l"]+1,brackpairs[i]["r"]);
		//console.log(substr);
		// /^\s*\w+\s*/
		if (result = substr.match(new RegExp("^\\s*"+utfsymb.not+"*\\s*\\w+\\s*"))) {
			//console.log("match1");
			if (result[0].length == brackpairs[i]["r"]-brackpairs[i]["l"]-1) {
				//spaces and var name are the all substr => delete brackets
				string = string.substring(0,brackpairs[i]["l"]) + " " +
					string.substring(brackpairs[i]["l"]+1,brackpairs[i]["r"]) + " " +
					string.substring(brackpairs[i]["r"]+1,string.length);
				brackpairs.splice(i,1);
				i--;
			} else if (substr[result[0].length]=="(") {
				//if there are brackets after name - functional
				//check if the brackets - all substr
				var end = result[0].length+readBracket(substr,result[0].length);
				substr = substr.substring(end,substr.length);
				if (substr.match(/^\s*$/)) {
					//delete brackets
					string = string.substring(0,brackpairs[i]["l"]) + " " +
						string.substring(brackpairs[i]["l"]+1,brackpairs[i]["r"]) + " " +
						string.substring(brackpairs[i]["r"]+1,string.length);					
					brackpairs.splice(i,1);
					i--;
				}
			}
		} else {
			//if there are no "free" elements
			var k = 0,counter = 0;
			for (k = 0;k<substr.length;k++) {
				if (substr[k]=="(") {
					counter++;
				}else if (substr[k]==")"){
					counter--;
				}else if (counter==0 && substr[k]!=utfsymb.not &&
					substr[k]!=" ") {
					k = -1;
					break;
				}
			}
			if (k != -1) {
				//we need to remove theese brackets
				string = string.substring(0,brackpairs[i]["l"]) + " " +
					string.substring(brackpairs[i]["l"]+1,brackpairs[i]["r"]) + " " +
					string.substring(brackpairs[i]["r"]+1,string.length);				
				brackpairs.splice(i,1);
				i--;
			}
		}
	}
	
	//console.log(string);
	//console.log(brackpairs);

	reg = new RegExp("\\s+","g");
	string = string.replace(reg,"");
	
	if (mode!="isolate" && isolated) {
		//remove border brackets
		if (brackpairs.length!= 0 &&
			brackpairs[0]["l"] == 0 && 
			brackpairs[0]["r"] == string.length-1 ) 
		{
			string = string.substring(1,string.length-1);
		}
	}
	
	/*
	reg = new RegExp("\\((\\w+)\\)(?=[^\\w]|$)","g");
	string = string.replace(reg,function(substr,p1,offset,str){
		if (offset==0) {
			return p1;
		} else if (str[offset-1].match(/\w/) == null) {
			return p1;
		} else {
			return "("+p1+")";
		}
	});*/
	//look-behind and look-ahead reg exp
	return string;
};

//=====================================================
//===============work with substitution================

function findFunctional(functionals, name, argnum) {
	var i = 0;
	for (i = 0;i<functionals.length;i++) {
		if (functionals[i].name == name &&
			functionals[i].vars.length == argnum) {
			return i;
		}
	}
	return -1;
};

function substituteVars (func,vars) {
	var i = 0;
	var reg;
	var value = func.value;
	//we assume that func is normalized
	//func value is normalized
	var varstring = func.vars.join("|");
	reg = new RegExp("([^\\w]|^)("+varstring+
		"(?=[^\\w\\(]|$))","g");
	value = value.replace(reg,function(substr,p1,p2,offset,str) {
		//get number of var
		var i = 0;
		for (i=0;i<func.vars.length;i++) {
			if (func.vars[i] == p2) {
				return p1+normalize(vars[i],"isolate");
			}
		}
		return p1+p2;
	});
	return value;
};

function substitute(functionals,string) {
	var reg = new RegExp("\\w+\\(","g");
	var prevstart = 0,prevend = 0,start = 0,end = 0;
	var existfunc = true;
	var existfuncinside = false;
	var newstring;
	var namereg;
	var funcind,subfuncind;
	var funcnumber;
	var funcvalue,funcname,subfuncvalue,subfuncname;
	var vars,subvars;
	//is this normalization needed
	string = normalize(string);
	while (existfunc) {
		existfunc = false;
		namereg = new RegExp("\\w+\\(","g");
		newstring = "";
		prevend = 0;
		while(funcind = readFunctional(namereg,string)) {
			start = funcind[0];
			end = funcind[2]+1;
			funcname = string.substring(start,funcind[1]);
			funcvalue = string.substring(funcind[1]+1,end-1);
			namereg2 = new RegExp("\\w+\\(","g");
			existfuncinside = false;
			while(subfuncind = readFunctional(namereg2,funcvalue)) {
				subfuncname = funcvalue.substring(subfuncind[0],
					subfuncind[1]);
				subfuncvalue = funcvalue.substring(subfuncind[1]+1,
					subfuncind[2]);
				funcnumber = findFunctional(functionals,subfuncname,
					readParams(subfuncvalue).length);
				if (funcnumber != -1) {
					//there are existing functional in funcvalue
					existfuncinside = true;
					break;
				}
				//if there is such functional => need to break fromhere
				//set existfuncinside => break;
			}
			funcnumber = findFunctional(functionals,funcname,
				readParams(funcvalue).length);
			if (existfuncinside) {
				if (funcnumber != -1) {
					existfunc = true;
				}
				continue;
			}
			if (funcnumber == -1) { continue; }
			//if name exist in functionals &&
			//if it has inside functional => existfunc = true
			//if inside there are no another functionals - 
			//count, in other case - continue
			var func = functionals[funcnumber];
			newstring = newstring+string.substring(prevend,start);
			newstring = newstring + 
				normalize(
				substituteVars(func,readParams(funcvalue)),
				"isolate" );//replace functional with isolated(value);
			prevend = end;
		}
		newstring = newstring+string.substring(prevend,string.length);
		string = newstring;
	}
	
	return string;
};

function fullsubstitute(functionals, string) {
	var newstring = substitute(functionals,string);
	while(newstring!=string) {
		string = newstring;
		newstring = substitute(functionals,string);
	}
	return newstring;
}


//===============work with substitution================
//=====================================================

function Functional() {
}
Functional.prototype = {
	string: "",
	name: "",
	vars: [],
	value: ""
};

function Logic1(context) {
	//this.objects = [];
	var rule = new Rule("Root");
	rule.x = 0;
	rule.y = 0;
	rule.width = 10;
	rule.height = 10;
	rule.elems[0] = "A";
	rule.setSize(context);
	
	this.tree = new Tree(rule);
	this.functionals = [];
	/*
		binary tree realization
		element	
	*/
}
Logic1.prototype = {
	tree: null,
	functionals: null,
	description: "",
	loadData: function (data) {
		this.tree.loadData(data.tree);
		this.functionals = data.functionals;
		if (this.functionals == null) {
			this.functionals = [];
		}
		this.description = data.description;
		if (data.description == null) {
			this.description = "";
		}
	},
	addFunctional: function(string,position) {
		var func = new Functional();
		var parsed = parseFunctional(func,string);
		this.functionals.splice(position,0,func);
		return parsed;
	},
	deleteFunctional: function(position) {
		this.functionals.splice(position,1);
	},
	changeFunctional: function(string,position) {
		var func = this.functionals[position];
		var parsed = parseFunctional(func,string);
		return parsed;
	},
	equals: function(string1,string2) {
		
	}
}

function Drawer(canvas) {
	this.canvas = canvas;
	this.canvasrect = {left: 0, top: 0};
	this.resizeCanvas();
	
	this.context = canvas.getContext("2d");
	
	this.context.font = this.fontsize+"pt Arial bold";
};
Drawer.prototype = {
/*
	this class special for drawing Logic object
	and for all gui
*/
	fontsize: 14,
	canvas: null,
	canvasrect: null,
	context: null,
	//logicobj: null,
	logictree: null,
	mousedown: false,
	startmoveset: false,
	startmovex: 0,
	startmovey: 0,
	currentx: 0,
	currenty: 0,
	offsetx: 0,
	offsety: 0,
	infocusnode: null,
	infocuselem: null,
	utf : {
		forall:"\u2200",
		exist:"\u2203",
		not:"\u00ac",
		or: "\u2228",
		and: "\u2227",
		implic: "\u2192"
	},
	initialize: function(tree) {
		//set logictree
		this.logictree = tree;
		
	},
	resizeCanvas: function() {
		var boundcli = this.canvas.getBoundingClientRect();
		this.canvasrect.left = boundcli.left;
		this.canvasrect.top = boundcli.top;
		this.canvasrect.left = this.canvasrect.left + window.pageXOffset;
		this.canvasrect.top = this.canvasrect.top + window.pageYOffset;
	},
	Draw: function() {
		//alert("Drawfun"+logicobj.length);
		var context = this.context;
		//var logicobj = this.logicobj;
		var elem;
		var currentx = this.currentx,
			currenty = this.currenty,
			startmovex = this.startmovex,
			startmovey = this.startmovey,
			offsetx = this.offsetx + (startmovex-currentx),
			offsety = this.offsety + (startmovey-currenty);
		context.clearRect(0,0,layout.canvas.width,layout.canvas.height);
		context.fillStyle = "rgba(120,0,0,2)";
		//context.strokeStyle = "#000000";
		//context.strokeStyle = "#FF0000";
		context.beginPath();
		
		
		var stack = [0];
		var curnode = this.logictree.rootnode;
		var parentnode;
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				curnode.element.draw(context,offsetx,offsety);
				
				if (stack.length != 0) {
					//Go to parent
					parent = curnode.parent;
					//draw there line between parent and child
					context.moveTo(parent.element.x+parent.element.width/2-offsetx,
						parent.element.y-offsety);
					context.lineTo(curnode.element.x+curnode.element.width/2-offsetx,
						curnode.element.y+curnode.element.height-offsety);
					
					curnode = parent;
					
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				}
			}
		}
		
		//context.strokeStyle = "rgba(255,0,0,255)";
		context.rect(0,0,layout.canvas.width,layout.canvas.height);
		context.stroke();
		context.closePath();
	},
	refreshSelector(selector,functionals) {
		var i = 0;
		var size = selector.options.length;
		var option;
		for (i = 0; i<size-1;i++) {
			selector.removeChild(selector.options[0]);
		}
		for (i = 0;i<functionals.length;i++) {
			option = document.createElement("option");
			option.text = functionals[i].string;
			if (parseFunctional(functionals[i],functionals[i].string)) {
				option.style.background = "rgba(0,255,0,0.5)";
			} else {
				option.style.background = "rgba(255,0,0,0.5)";
			}
			selector.insertBefore(option,selector.options[i]);
		}
		//var i = 0;
		//for (i = 0;)
	},
	resetStartmove: function() {
		if (this.startmoveset) {
			this.offsetx = this.offsetx + (this.startmovex-this.currentx);
			this.offsety = this.offsety + (this.startmovey-this.currenty);
			this.startmovex = 0;
			this.startmovey = 0;
			this.currentx = 0;
			this.currenty = 0;
			this.startmoveset = false;
		}
	},
	inRect: function(x,y,rectx,recty,width,height) {
		//alert("inrect "+x+" "+y+" "+" "+rectx+" "+recty+" "+width+" "+height);
		if (x>=rectx && y>=recty && x<=rectx+width && y<=recty+height) {
			return true;
		} else {
			return false;
		}
	},
	findFocus: function() {
		//go through all objects
		//set infocus element;
		var i = 0;
		//var logicobj = this.logicobj;
		var elem;
		var canvclickx = event.pageX - this.canvasrect.left;
		var canvclicky = event.pageY - this.canvasrect.top;
		//var canvclickx = event.pageX - (this.canvasrect.left+window.scrollX);
		//var canvclicky = event.pageY - (this.canvasrect.top+window.scrollY);
		var elemcanvx = 0;
		var elemcanvy = 0;
		this.infocuselem = null;
		this.infocusnode = null;
		
		var stack = [0];
		var curnode = this.logictree.rootnode;
		var parentnode;
		var curchildnum;
		while(stack.length != 0) {
			//if there are child - go to child
			curchildnum = stack[stack.length-1];
			if (curnode.childs.length > curchildnum) {
				if (curnode.childs[curchildnum] != null) {
					curnode = curnode.childs[curchildnum];
					stack.push(0);
				} else {
					stack[stack.length-1] = curchildnum + 1;
				}
			} else {
				//curnode - there are no childs
				//process current node then up and 
				stack.pop();
				
				elem = curnode.element;
				elem.unsetFocus();
				elemcanvx = elem.x-this.offsetx+(this.currentx-this.startmovex);
				elemcanvy = elem.y-this.offsety+(this.currenty-this.startmovey);				
				if (this.inRect(canvclickx,canvclicky,elemcanvx,elemcanvy,
					elem.width,elem.height)) {
					elem.setFocus(canvclickx-elemcanvx,canvclicky-elemcanvy);
					this.infocuselem = elem;
					this.infocusnode = curnode;
					//alert("findFocus! set focus");
				}						
				
				if (stack.length != 0) {
					//Go to parent
					curnode = curnode.parent;
					//Go to next child
					curchildnum = stack[stack.length-1];
					stack[stack.length-1] = curchildnum+1;
				}
			}
		}
		
		if (this.infocuselem != null && this.infocuselem.focusedelem != -1) {
			layout.edittext.value = this.infocuselem.elems[this.infocuselem.focusedelem];
		} else {
			layout.edittext.value = "NONE";
		}	
	
		/*
		for (i = 0;i<logicobj.length;i++) {
			elem = logicobj[i];
			elem.unsetFocus();
			elemcanvx = elem.x-this.offsetx+(this.currentx-this.startmovex);
			elemcanvy = elem.y-this.offsety+(this.currenty-this.startmovey);
			//alert(" "+canvclickx+" "+canvclicky+" "+elemcanvx+" "+elemcanvy+" "+elem.x+" "+elem.y);
			var inr = this.inRect(canvclickx,canvclicky,elemcanvx,elemcanvy,
				elem.width,elem.height);
			if (this.inRect(canvclickx,canvclicky,elemcanvx,elemcanvy,
				elem.width,elem.height)) {
				elem.setFocus(canvclickx-elemcanvx,canvclicky-elemcanvy);
				this.infocuselem = elem;
				//alert("findFocus! set focus");
			}

			//oncanvas position:
			//	elem.x-offsetx+(currentx-startx)
			//	elem.y-offsety+(curremty-starty)
			//	event.pageX - (rect.left+window.scrollX)

			if (this.infocuselem != null) {
				layout.edittext.value = this.infocuselem.elems[this.infocuselem.focusedelem];
			} else {
				layout.edittext.value = "NONE";
			}
		}*/
		
	},
	refreshEditText() {
		if (this.infocuselem != null && this.infocuselem.focusedelem != -1) {
			layout.edittext.value = this.infocuselem.elems[this.infocuselem.focusedelem];
		} else {
			layout.edittext.value = "NONE";
		}	
	}
};

function HtmlLayout() {
	//alert("HtmlLayout");
	this.fileselector = document.getElementById("fileselector");
	this.filegetter = document.getElementById("filegetter");
	this.edittext = document.getElementById("edittext");
	this.canvas = document.getElementById("canvas");
	this.butconfirm = document.getElementById("butconfirm");
	this.butgenrule = document.getElementById("butgenrule");
	this.butmprule = document.getElementById("butmprule");
	this.butdeleterule = document.getElementById("butdeleterule");

	this.butgroupconfirm = document.getElementById("butgroupconfirm");
	this.butdisclose = document.getElementById("butdisclose");
	
	this.tadescr = document.getElementById("tadescr");
	this.tamessages = document.getElementById("tamessages");
	
	//axioms
	this.butaddaxiom = document.getElementById("butaddaxiom");
	this.butdeleteaxiom = document.getElementById("butdeleteaxiom");
	this.butconfirmaxiom = document.getElementById("butconfirmaxiom");
	this.selaxioms = document.getElementById("selaxioms");
	this.edittextaxiom = document.getElementById("edittextaxiom");
	
	//scale
	this.butscalep = document.getElementById("butscalep");
	this.butscalem = document.getElementById("butscalem");
};
HtmlLayout.prototype = {
	fileselector: null,
	filegetter: null,
	edittext: null,
	canvas: null,
	butconfirm: null,
	butgenrule: null,
	butmprule: null,
	butdeleterule: null,

	butregroupconfirm: null,
	butdisclose: null,
	
	tadescr: null,
	tamessages:null,
	
	//axioms:
	butaddaxiom: null,
	butdeleteaxiom: null,
	butconfirmaxiom: null,
	selaxioms: null,
	edittextaxiom: null,
	
	//scale
	butscalep: null,
	butscalem: null
};
</script>

<style>
span.overline {
	text-decoration: overline;
}
</style>
<meta charset="UTF-8">
<title>NO TITLE</title>
</head>
<body>
<!--
<div>
<span class="overline">ASDGHJ&nbsp;&nbsp;</span><sup>SS</sup><u>&nbsp;&nbsp;&nbsp;&nbsp;QWER&nbsp;&nbsp;&nbsp;&nbsp;</u><sub>SP</sub>
</div>-->
<input type="file" id="fileselector" />
<a dialogtype="save" id="filegetter">Get File</a> <br/>
<table border="2" bordercolor="#FF0000">
<tr>
<td valign="top" style="min-width: 100pt;">
Functionals List: <br/>
<select id="selaxioms" size="10" charset="UTF-8" style="width: 100%;">
<option style="background: rgba(0,0,0,0.25);"></option>
</select> <br/>
Functional Representation: <br/>
<input id="edittextaxiom" style="width:95%;" type="text" /> <br/>
<table>
<tr>
<td>
<button id="butconfirmaxiom">CONFIRM</button>
</td> <td>
<button id="butaddaxiom">ADD</button>
</td> <td>
<button id="butdeleteaxiom">DELETE</button>
</td>
</tr>
</table> <br/>
Description:<br/>
<textarea id="tadescr" style="width:95%; height: 400px;"></textarea> <br/>
Messages:<br/>
<textarea id="tamessages" style="width:95%; height: 100px;"></textarea>
</td>
<td>
<input id="edittext" value="" type="text" text="temp"/>
<!-- &#x2200;-->
<button id="butconfirm">CONFIRM</button>
<button id="butmprule">MP</button>
<button id="butgenrule">GEN</button>
<button id="butdeleterule">Delete</button> <br/>
<button id="butgroupconfirm">GROUPING</button>
<button id="butdisclose">DISCLOSE</button>
&nbsp;&nbsp;&nbsp;&nbsp;
<button id="butscalep">Scale +</button>
<button id="butscalem">Scale -</button> <br/>
<canvas width="1200" height="870" style="display: inline-block; " background-color="#3366CC" id="canvas">Что-то не то</canvas>
</td>
</tr>
</table>
<script type="text/javascript">
var layout = new HtmlLayout();
var drawer = new Drawer(layout.canvas);
var logic = new Logic1(drawer.context);
drawer.initialize(logic.tree);
//initialization of logictree
var object = null;

//============DEBUG+PART==============
//console.log("((¬B)→((A→¬B)→(¬A)))→((¬B→(A→¬B))→(¬B→¬A))");
//console.log("normalized:"+normalize( "(¬B→((A→¬B)→¬A))→((¬B→(A→¬B))→(¬B→¬A))" ));
//console.log("((¬B)())");
//console.log(normalize("((¬B)())"));
//console.log("!!as    ".match(/\w+\s*$/));
//====================================

layout.canvas.style.cursor = "move";

//var filegetter = document.getElementById("Filegetter");
layout.filegetter.href= "";
layout.filegetter.onclick = function() {
	logic.tree.deleteParents();
	logic.description = layout.tadescr.value;
	var data = new Blob([JSON.stringify(logic)],{type: 'data:attachment/text'});
	layout.filegetter.href = window.URL.createObjectURL(data);
	layout.filegetter.download = "myfilename.txt"
	logic.tree.addParents();
};

var filereader = new FileReader();
filereader.onload = function(event) {
	//layout.edittext.value = event.target.result;
	var logicdata = JSON.parse(event.target.result);
	logic.loadData(logicdata);
	logic.tree.addParents();
	
	drawer.infocusnode = null;
	if (drawer.infocuselem != null) {
		drawer.infocuselem.focusedelem = -1;
		drawer.infocuselem = null;
	}
	drawer.initialize(logic.tree);
	drawer.refreshEditText();
	layout.tadescr.value = logic.description;
	drawer.refreshSelector(layout.selaxioms,logic.functionals);
	drawer.logictree.recountTree(drawer.context);
	drawer.Draw();
	//@TODO: set this tree for the others
};

function onFileSelect(event) {
	var file = event.target.files[0];
	//edittext.value = "Size = "+file.size;
	filereader.readAsText(file);
}

//var fileselector = document.getElementById("fileselector");
layout.fileselector.addEventListener('change',onFileSelect,false);

//window.setInterval(function() {drawer.resizeCanvas();}, 1000);
window.onresize = function (event) {
	drawer.resizeCanvas();
};
//var canv = document.getElementById("canvas");

//logic.tree.deleteElement(logic.tree.rootnode,0);

drawer.Draw();

layout.canvas.onclick = function () {
	if (!drawer.startmoveset) {
		drawer.findFocus();
		drawer.Draw();
	} else {
		drawer.resetStartmove();
	}
}

layout.canvas.onmousedown = function () {
	drawer.mousedown = true;
	drawer.startmoveset = false;
}

layout.canvas.onmouseup = function () {
	drawer.mousedown = false;
}

layout.canvas.onmousemove = function(event) {
	if (drawer.mousedown) {
		drawer.currentx = event.pageX;
		drawer.currenty = event.pageY;
		if (!drawer.startmoveset) {
			drawer.startmoveset = true;
			drawer.startmovex = event.pageX;
			drawer.startmovey = event.pageY;
		}
		//need to redraw
		drawer.Draw();
	}
};

//AXIOMS:
layout.butconfirmaxiom.onclick = function() {
	var selind = layout.selaxioms.selectedIndex;
	if (selind == layout.selaxioms.options.length-1) {
		return;
	}
	var string = layout.edittextaxiom.value;
	if (logic.changeFunctional(string,selind)) {
		layout.selaxioms.options[selind].style.background = "rgba(0,255,0,0.5)";
	} else {
		layout.selaxioms.options[selind].style.background = "rgba(255,0,0,0.5)";
	}
	layout.selaxioms.options[selind].text = string;
	console.log(logic.functionals);
};

layout.butdeleteaxiom.onclick = function() {
	var selind = layout.selaxioms.selectedIndex;
	if (selind == layout.selaxioms.options.length-1) {
		return;
	}
	layout.selaxioms.removeChild(layout.selaxioms.options[selind]);
	console.log(layout.selaxioms.selectedIndex);
	//console.log(layout.selaxioms.options[]);
};

layout.butaddaxiom.onclick = function() {
	var selind = layout.selaxioms.selectedIndex;
	var option = document.createElement("option");
	console.log(layout.selaxioms.options);
	option.text = "NEW AXIOM";
	option.style.background = "rgba(255,0,0,0.5)";
	if (selind != -1) {
		layout.selaxioms.insertBefore(option,layout.selaxioms.options[selind]);
		logic.addFunctional(option.text,selind);
	} else {
		//layout.selaxioms.add(option);
	}
	console.log(logic.functionals);
};

layout.selaxioms.onchange = function() {
	var selind = layout.selaxioms.selectedIndex;
	if (selind != -1) {
		layout.edittextaxiom.value = layout.selaxioms.options[selind].text;
	} else {
		layout.edittextaxiom.value = "NONE";
	}
	console.log("selaxioms.change");
};

//VISUALIZER
layout.butconfirm.onclick = function() {
	if (drawer.infocuselem != null) {
		var infocuselem = drawer.infocuselem;
		if (infocuselem.focusedelem != -1) {
			drawer.logictree.changeRule(drawer.infocusnode,infocuselem.focusedelem,layout.edittext.value,drawer.context);
			drawer.refreshEditText();
			drawer.Draw();
		}
	}
};

layout.butdeleterule.onclick = function () {
	if (drawer.infocuselem != null) {
		var infocuselem = drawer.infocuselem;
		if (infocuselem.focusedelem != -1) {
			drawer.logictree.deleteElement(drawer.infocusnode,infocuselem.focusedelem);
			drawer.Draw();
		}
	} 
};

layout.butgenrule.onclick = function() {
	if (drawer.infocuselem != null) {
		var infocuselem = drawer.infocuselem;
		if (infocuselem.focusedelem != -1) {
			//need to add new rule
			var elem = new Rule("GEN");
			//@TODO:set fields for GEN
			if (!elem.autosetgen(infocuselem.elems[infocuselem.focusedelem])) {
				alert("cannot remove "+utfsymb.forall+" 'var' from "
					+infocuselem.elems[infocuselem.focusedelem]);
				return;
			}
			//========================
			elem.setSize(drawer.context);
			if (infocuselem.type == "Root" ||
				infocuselem.type == "GEN") {
				logic.tree.addElement(drawer.infocusnode,elem,"center");
			} else if (infocuselem.type == "MP") {
				if (infocuselem.focusedelem == 0) {
					//left
					logic.tree.addElement(drawer.infocusnode,elem,"left");
				} else {
					//right
					logic.tree.addElement(drawer.infocusnode,elem,"right");
				}
			}			
			
			drawer.Draw();
		}		
	}
}

layout.butmprule.onclick = function() {
	if (drawer.infocuselem != null) {
		var infocuselem = drawer.infocuselem;
		if (infocuselem.focusedelem != -1) {
			//create element: need to create fields of it
			var elem = new Rule("MP");
			//@TODO:set fields for MP
			elem.autosetmp("t0",infocuselem.elems[infocuselem.focusedelem]);
			//=======================
			elem.setSize(drawer.context);
			if (infocuselem.type == "Root" ||
				infocuselem.type == "GEN") {
				logic.tree.addElement(drawer.infocusnode,elem,"center");
			} else if (infocuselem.type == "MP") {
				if (infocuselem.focusedelem == 0) {
					//left
					logic.tree.addElement(drawer.infocusnode,elem,"left");
				} else {
					//right
					logic.tree.addElement(drawer.infocusnode,elem,"right");
				}
			}
			drawer.Draw();
		}		
	}	
}

layout.butgroupconfirm.onclick = function() {
	if (drawer.infocuselem != null) {
		var stringedit = layout.edittext.value;
		var stringeditnorm = normalize(
			fullsubstitute(logic.functionals,stringedit));
		//var stringeditnorm = substitute(logic.functionals,stringedit);
		var stringelem = drawer.infocuselem.elems[drawer.infocuselem.focusedelem];
		var stringelemnorm = normalize(
			fullsubstitute(logic.functionals,stringelem));
		console.log(stringeditnorm,stringelemnorm);
		if (stringeditnorm == stringelemnorm) {	
			layout.tamessages.value = "";
			var infocuselem = drawer.infocuselem;
			infocuselem.elems[infocuselem.focusedelem] = stringedit;
			drawer.infocusnode.element.setSize(drawer.context);
			drawer.logictree.changed(drawer.infocusnode);
			drawer.Draw();
		} else {
			layout.tamessages.value = "Error!\n"+"Input:\n"+
				stringeditnorm+"\nChangeable Field:\n"+
				stringelemnorm;
		}
	}
}

layout.butdisclose.onclick = function() {
	if (drawer.infocuselem != null) {
		var infocuselem = drawer.infocuselem;
		var string = infocuselem.elems[infocuselem.focusedelem];
		string = substitute(logic.functionals,string);
		infocuselem.elems[infocuselem.focusedelem] = string;
		drawer.infocusnode.element.setSize(drawer.context);
		drawer.logictree.changed(drawer.infocusnode);
		drawer.refreshEditText();
		drawer.Draw();
	}
}

//SCALE
layout.butscalep.onclick = function() {
	if (drawer.fontsize<30) {
		drawer.fontsize = drawer.fontsize + 1;
	}
	drawer.context.font = drawer.fontsize+"pt Arial bold";
	logic.tree.recountTree(drawer.context);
	drawer.Draw();
}

layout.butscalem.onclick = function() {
	if (drawer.fontsize>6) {
		drawer.fontsize = drawer.fontsize - 1;
	}
	drawer.context.font = drawer.fontsize+"pt Arial bold";
	logic.tree.recountTree(drawer.context);
	drawer.Draw();
}
 
layout.edittext.oninput = function() {
	var string = layout.edittext.value;
	var regexp = /\\implication|->/;
	var i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.implic);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}

	//regexp = new RegExp(drawer.utf.implic+drawer.urf.implic);
	
	regexp = /\\and|&/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.and);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}
	regexp = /\\or/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.or);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}
	regexp = /\\not/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.not);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}
	regexp = /\\forall/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.forall);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}
	regexp = /\\exist/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.exist);
		layout.edittext.value = string;
		layout.edittext.setSelectionRange(i+1,i+1);
	}
};

layout.edittextaxiom.oninput = function() {
	var string = layout.edittextaxiom.value;
	var regexp = /\\implication|->/;
	var i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.implic);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}

	//regexp = new RegExp(drawer.utf.implic+drawer.urf.implic);
	
	regexp = /\\and|&/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.and);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}
	regexp = /\\or/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.or);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}
	regexp = /\\not/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.not);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}
	regexp = /\\forall/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.forall);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}
	regexp = /\\exist/;
	i = string.search(regexp);
	if (i != -1) {
		string = string.replace(regexp,drawer.utf.exist);
		layout.edittextaxiom.value = string;
		layout.edittextaxiom.setSelectionRange(i+1,i+1);
	}
};

//http://www.w3schools.com/charsets/ref_html_utf8.asp
//setInterval(function(){alert("ALERT");}, 3000);
/*
var worker = new Worker("worker.js");
worker.onmessage = function(event) {
	console.log("");
}*/
layout.edittext.value=drawer.utf.implic;

</script>
</body>
</html>